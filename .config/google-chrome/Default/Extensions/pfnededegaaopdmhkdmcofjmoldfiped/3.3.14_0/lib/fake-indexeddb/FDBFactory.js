import FDBDatabase from"./FDBDatabase.js";import FDBOpenDBRequest from"./FDBOpenDBRequest.js";import FDBVersionChangeEvent from"./FDBVersionChangeEvent.js";import cmp from"./lib/cmp.js";import Database from"./lib/Database.js";import enforceRange from"./lib/enforceRange.js";import{AbortError,VersionError}from"./lib/errors.js";import FakeEvent from"./lib/FakeEvent.js";import{queueTask}from"./lib/scheduling.js";const waitForOthersClosedDelete=(databases,name,openDatabases,cb)=>{openDatabases.some((openDatabase2=>!openDatabase2._closed&&!openDatabase2._closePending))?queueTask((()=>waitForOthersClosedDelete(databases,name,openDatabases,cb))):(databases.delete(name),cb(null))},deleteDatabase=(databases,name,request,cb)=>{try{const db=databases.get(name);if(void 0===db)return void cb(null);db.deletePending=!0;const openDatabases=db.connections.filter((connection=>!connection._closed&&!connection._closePending));for(const openDatabase2 of openDatabases)if(!openDatabase2._closePending){const event=new FDBVersionChangeEvent("versionchange",{newVersion:null,oldVersion:db.version});openDatabase2.dispatchEvent(event)}const anyOpen=openDatabases.some((openDatabase3=>!openDatabase3._closed&&!openDatabase3._closePending));if(request&&anyOpen){const event=new FDBVersionChangeEvent("blocked",{newVersion:null,oldVersion:db.version});request.dispatchEvent(event)}waitForOthersClosedDelete(databases,name,openDatabases,cb)}catch(err){cb(err)}},runVersionchangeTransaction=(connection,version,request,cb)=>{connection._runningVersionchangeTransaction=!0;const oldVersion=connection.version,openDatabases=connection._rawDatabase.connections.filter((otherDatabase=>connection!==otherDatabase));for(const openDatabase2 of openDatabases)if(!openDatabase2._closed&&!openDatabase2._closePending){const event=new FDBVersionChangeEvent("versionchange",{newVersion:version,oldVersion:oldVersion});openDatabase2.dispatchEvent(event)}if(openDatabases.some((openDatabase3=>!openDatabase3._closed&&!openDatabase3._closePending))){const event=new FDBVersionChangeEvent("blocked",{newVersion:version,oldVersion:oldVersion});request.dispatchEvent(event)}const waitForOthersClosed=()=>{if(openDatabases.some((openDatabase2=>!openDatabase2._closed&&!openDatabase2._closePending)))return void queueTask(waitForOthersClosed);connection._rawDatabase.version=version,connection.version=version;const transaction=connection.transaction(connection.objectStoreNames,"versionchange");request.result=connection,request.readyState="done",request.transaction=transaction,transaction._rollbackLog.push((()=>{connection._rawDatabase.version=oldVersion,connection.version=oldVersion}));const event=new FDBVersionChangeEvent("upgradeneeded",{newVersion:version,oldVersion:oldVersion});request.dispatchEvent(event),transaction.addEventListener("error",(()=>{connection._runningVersionchangeTransaction=!1})),transaction.addEventListener("abort",(()=>{connection._runningVersionchangeTransaction=!1,request.transaction=null,queueTask((()=>{cb(new AbortError)}))})),transaction.addEventListener("complete",(()=>{connection._runningVersionchangeTransaction=!1,request.transaction=null,queueTask((()=>{connection._closePending?cb(new AbortError):cb(null)}))}))};waitForOthersClosed()},openDatabase=(databases,name,version,request,cb)=>{let db=databases.get(name);if(void 0===db&&(db=new Database(name,0),databases.set(name,db)),void 0===version&&(version=0!==db.version?db.version:1),db.version>version)return cb(new VersionError);const connection=new FDBDatabase(db);db.version<version?runVersionchangeTransaction(connection,version,request,(err=>{if(err)return cb(err);cb(null,connection)})):cb(null,connection)};class FDBFactory{cmp=cmp;_databases=new Map;deleteDatabase(name){const request=new FDBOpenDBRequest;return request.source=null,queueTask((()=>{const db=this._databases.get(name),oldVersion=void 0!==db?db.version:0;deleteDatabase(this._databases,name,request,(err=>{if(err){request.error=new DOMException(err.message,err.name),request.readyState="done";const event=new FakeEvent("error",{bubbles:!0,cancelable:!0});return event.eventPath=[],void request.dispatchEvent(event)}request.result=void 0,request.readyState="done";const event2=new FDBVersionChangeEvent("success",{newVersion:null,oldVersion:oldVersion});request.dispatchEvent(event2)}))})),request}open(name,version){if(arguments.length>1&&void 0!==version&&(version=enforceRange(version,"MAX_SAFE_INTEGER")),0===version)throw new TypeError;const request=new FDBOpenDBRequest;return request.source=null,queueTask((()=>{openDatabase(this._databases,name,version,request,((err,connection)=>{if(err){request.result=void 0,request.readyState="done",request.error=new DOMException(err.message,err.name);const event=new FakeEvent("error",{bubbles:!0,cancelable:!0});return event.eventPath=[],void request.dispatchEvent(event)}request.result=connection,request.readyState="done";const event2=new FakeEvent("success");event2.eventPath=[],request.dispatchEvent(event2)}))})),request}databases(){return new Promise((resolve=>{const result=[];for(const[name,database]of this._databases)result.push({name:name,version:database.version});resolve(result)}))}toString(){return"[object IDBFactory]"}}export default FDBFactory;