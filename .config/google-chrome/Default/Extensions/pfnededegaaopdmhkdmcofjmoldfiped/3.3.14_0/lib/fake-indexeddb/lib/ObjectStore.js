import{ConstraintError,DataError}from"./errors.js";import extractKey from"./extractKey.js";import KeyGenerator from"./KeyGenerator.js";import RecordStore from"./RecordStore.js";class ObjectStore{deleted=!1;records=new RecordStore;rawIndexes=new Map;constructor(rawDatabase,name,keyPath,autoIncrement){this.rawDatabase=rawDatabase,this.keyGenerator=!0===autoIncrement?new KeyGenerator:null,this.deleted=!1,this.name=name,this.keyPath=keyPath,this.autoIncrement=autoIncrement}getKey(key){const record=this.records.get(key);return void 0!==record?structuredClone(record.key):void 0}getAllKeys(range,count){void 0!==count&&0!==count||(count=1/0);const records=[];for(const record of this.records.values(range))if(records.push(structuredClone(record.key)),records.length>=count)break;return records}getValue(key){const record=this.records.get(key);return void 0!==record?structuredClone(record.value):void 0}getAllValues(range,count){void 0!==count&&0!==count||(count=1/0);const records=[];for(const record of this.records.values(range))if(records.push(structuredClone(record.value)),records.length>=count)break;return records}storeRecord(newRecord,noOverwrite,rollbackLog){if(null!==this.keyPath){const key=extractKey(this.keyPath,newRecord.value);void 0!==key&&(newRecord.key=key)}if(null!==this.keyGenerator&&void 0===newRecord.key){if(rollbackLog){const keyGeneratorBefore=this.keyGenerator.num;rollbackLog.push((()=>{this.keyGenerator&&(this.keyGenerator.num=keyGeneratorBefore)}))}if(newRecord.key=this.keyGenerator.next(),null!==this.keyPath){if(Array.isArray(this.keyPath))throw new Error("Cannot have an array key path in an object store with a key generator");let identifier,remainingKeyPath=this.keyPath,object=newRecord.value,i=0;for(;i>=0;){if("object"!=typeof object)throw new DataError;i=remainingKeyPath.indexOf("."),i>=0&&(identifier=remainingKeyPath.slice(0,i),remainingKeyPath=remainingKeyPath.slice(i+1),Object.hasOwn(object,identifier)||(object[identifier]={}),object=object[identifier])}identifier=remainingKeyPath,object[identifier]=newRecord.key}}else null!==this.keyGenerator&&"number"==typeof newRecord.key&&this.keyGenerator.setIfLarger(newRecord.key);if(this.records.get(newRecord.key)){if(noOverwrite)throw new ConstraintError;this.deleteRecord(newRecord.key,rollbackLog)}this.records.add(newRecord),rollbackLog&&rollbackLog.push((()=>{this.deleteRecord(newRecord.key)}));for(const rawIndex of this.rawIndexes.values())rawIndex.initialized&&rawIndex.storeRecord(newRecord);return newRecord.key}deleteRecord(key,rollbackLog){const deletedRecords=this.records.delete(key);if(rollbackLog)for(const record of deletedRecords)rollbackLog.push((()=>{this.storeRecord(record,!0)}));for(const rawIndex of this.rawIndexes.values())rawIndex.records.deleteByValue(key)}clear(rollbackLog){const deletedRecords=this.records.clear();if(rollbackLog)for(const record of deletedRecords)rollbackLog.push((()=>{this.storeRecord(record,!0)}));for(const rawIndex of this.rawIndexes.values())rawIndex.records.clear()}count(range){let count=0;for(const record of this.records.values(range))count+=1;return count}}export default ObjectStore;