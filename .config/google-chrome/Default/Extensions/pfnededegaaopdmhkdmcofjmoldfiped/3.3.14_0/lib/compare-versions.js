!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports):"function"==typeof define&&define.amd?define(["exports"],factory):factory((global="undefined"!=typeof globalThis?globalThis:global||self).compareVersions={})}(this,(function(exports){"use strict";const semver=/^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i,validateAndParse=version=>{if("string"!=typeof version)throw new TypeError("Invalid argument expected string");const match=version.match(semver);if(!match)throw new Error(`Invalid argument not valid semver ('${version}' received)`);return match.shift(),match},isWildcard=s=>"*"===s||"x"===s||"X"===s,tryParse=v=>{const n=parseInt(v,10);return isNaN(n)?v:n},forceType=(a,b)=>typeof a!=typeof b?[String(a),String(b)]:[a,b],compareStrings=(a,b)=>{if(isWildcard(a)||isWildcard(b))return 0;const[ap,bp]=forceType(tryParse(a),tryParse(b));return ap>bp?1:ap<bp?-1:0},compareSegments=(a,b)=>{for(let i=0;i<Math.max(a.length,b.length);i++){const r=compareStrings(a[i]||"0",b[i]||"0");if(0!==r)return r}return 0},compareVersions=(v1,v2)=>{const n1=validateAndParse(v1),n2=validateAndParse(v2),p1=n1.pop(),p2=n2.pop(),r=compareSegments(n1,n2);return 0!==r?r:p1&&p2?compareSegments(p1.split("."),p2.split(".")):p1||p2?p1?-1:1:0},compare=(v1,v2,operator)=>{assertValidOperator(operator);const res=compareVersions(v1,v2);return operatorResMap[operator].includes(res)},operatorResMap={">":[1],">=":[0,1],"=":[0],"<=":[-1,0],"<":[-1],"!=":[-1,1]},allowedOperators=Object.keys(operatorResMap),assertValidOperator=op=>{if("string"!=typeof op)throw new TypeError("Invalid operator type, expected string but got "+typeof op);if(-1===allowedOperators.indexOf(op))throw new Error(`Invalid operator, expected one of ${allowedOperators.join("|")}`)},satisfies=(version,range)=>{if((range=range.replace(/([><=]+)\s+/g,"$1")).includes("||"))return range.split("||").some((r=>satisfies(version,r)));if(range.includes(" - ")){const[a,b]=range.split(" - ",2);return satisfies(version,`>=${a} <=${b}`)}if(range.includes(" "))return range.trim().replace(/\s{2,}/g," ").split(" ").every((r=>satisfies(version,r)));const m=range.match(/^([<>=~^]+)/),op=m?m[1]:"=";if("^"!==op&&"~"!==op)return compare(version,range,op);const[v1,v2,v3,,vp]=validateAndParse(version),[r1,r2,r3,,rp]=validateAndParse(range),v=[v1,v2,v3],r=[r1,null!=r2?r2:"x",null!=r3?r3:"x"];if(rp){if(!vp)return!1;if(0!==compareSegments(v,r))return!1;if(-1===compareSegments(vp.split("."),rp.split(".")))return!1}const nonZero=r.findIndex((v=>"0"!==v))+1,i="~"===op?2:nonZero>1?nonZero:1;return 0===compareSegments(v.slice(0,i),r.slice(0,i))&&-1!==compareSegments(v.slice(i),r.slice(i))},validate=version=>"string"==typeof version&&/^[v\d]/.test(version)&&semver.test(version),validateStrict=version=>"string"==typeof version&&/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(version);exports.compare=compare,exports.compareVersions=compareVersions,exports.satisfies=satisfies,exports.validate=validate,exports.validateStrict=validateStrict}));